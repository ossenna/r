result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/nperm
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
## Devoir 1 - Question 2
## Étape 0. Indiquer l'espace de travail et charger les données dans la matrice D
##
setwd("~/Desktop/R_mydirectory/devoir1")
D <- matrix(scan("Q2_donnees.dat"),10,10,byrow=TRUE)
D
## Étape 1. Ordonner les gènes en décroissant de différentiel d’expression
# Calculer la différence des moyennes pour chaque gène, dans chaque groupe
Ddiff <- abs(rowMeans(D[,1:5]) - rowMeans(D[,6:10]))
Dmoy <- cbind(D, Ddiff)
# Mettre en ordre décroissant
Ddec <- Dmoy[order(Dmoy[,11], decreasing= TRUE),]
## Étape 2. Marche (somme cumulative) avec le sous-groupe étudié: G1, G3, G6
# Définitions de paramètres n (nombre de données) et g (nombre de données dans le sous-ensemble)
n <- 10
g <- 3
# Valeur d'un pas positif
pp <- sqrt((n-g)/g)
pp
# Valeur d'un pas négatif
pn <- -sqrt(g/(n-g))
pn
# Fonction "marche" avec les pas calculés et les données initiales (non-permutées)
marche<-function(donnees1, donnees2)
{
x <- vector(mode="numeric", length = 11)
x
for(i in 2:length(x)){
if(all(donnees1[i-1,] == donnees2[1,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[3,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[6,])){
x[i] <- x[i-1]+pp
} else {
x[i] <- x[i-1]+pn
}
}
return(x)
}
x<-marche(Ddec, Dmoy)
# Représentation graphique de la marche et du supremum
sup <- max(x)
plot(x, ylim =c(-3,3), type="b", col=ifelse(x==sup, "darkseagreen", "darkseagreen4"),
pch=ifelse(x==sup, 18, 1), cex=ifelse(x==sup, 1.5, 1))
## Étape 3: Permuter les groupes de données 10 fois
## et appliquer la fonction "marche" à chaque permutation
cnt <- 0
Ytot <- matrix(0, nrow=0, ncol=11)
permutation <- function(nb)
{
repeat{
cnt <- cnt+1
# Permutations des numéros de colonnes
permusam1 <- sample(c(1:5), sample(1:4))
permusam2 <- sample(c(6:10), sample(1:4))
a <- setdiff(1:5,permusam1)
aa <- sample(c(a,permusam2))
b <- setdiff(6:10,permusam2)
bb <- sample(c(b,permusam1))
# le vecteur c(aa,bb) représente l'ordre des indices de colonnes une fois permutée
DP <- matrix(c(D[,aa], D[,bb]), nrow = 10, ncol=10)
DPdiff <- abs(rowMeans(DP[,1:5]) - rowMeans(DP[,6:10]))
DPmoy <- cbind(DP, DPdiff)
# Mettre en ordre décroissant
DPdec <- DPmoy[order(DPmoy[,11], decreasing= TRUE),]
y <- marche(DPdec, DPmoy)
Ytot <- rbind(Ytot,y)
if(cnt == nb) {
break
}
}
return(Ytot)
}
result <- permutation(10)
result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/nperm
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
## Devoir 1 - Question 2
## Étape 0. Indiquer l'espace de travail et charger les données dans la matrice D
##
setwd("~/Desktop/R_mydirectory/devoir1")
D <- matrix(scan("Q2_donnees.dat"),10,10,byrow=TRUE)
D
## Étape 1. Ordonner les gènes en décroissant de différentiel d’expression
# Calculer la différence des moyennes pour chaque gène, dans chaque groupe
Ddiff <- abs(rowMeans(D[,1:5]) - rowMeans(D[,6:10]))
Dmoy <- cbind(D, Ddiff)
# Mettre en ordre décroissant
Ddec <- Dmoy[order(Dmoy[,11], decreasing= TRUE),]
## Étape 2. Marche (somme cumulative) avec le sous-groupe étudié: G1, G3, G6
# Définitions de paramètres n (nombre de données) et g (nombre de données dans le sous-ensemble)
n <- 10
g <- 3
# Valeur d'un pas positif
pp <- sqrt((n-g)/g)
pp
# Valeur d'un pas négatif
pn <- -sqrt(g/(n-g))
pn
# Fonction "marche" avec les pas calculés et les données initiales (non-permutées)
marche<-function(donnees1, donnees2)
{
x <- vector(mode="numeric", length = 11)
x
for(i in 2:length(x)){
if(all(donnees1[i-1,] == donnees2[1,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[3,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[6,])){
x[i] <- x[i-1]+pp
} else {
x[i] <- x[i-1]+pn
}
}
return(x)
}
x<-marche(Ddec, Dmoy)
# Représentation graphique de la marche et du supremum
sup <- max(x)
plot(x, ylim =c(-3,3), type="b", col=ifelse(x==sup, "darkseagreen", "darkseagreen4"),
pch=ifelse(x==sup, 18, 1), cex=ifelse(x==sup, 1.5, 1))
## Étape 3: Permuter les groupes de données 10 fois
## et appliquer la fonction "marche" à chaque permutation
cnt <- 0
Ytot <- matrix(0, nrow=0, ncol=11)
permutation <- function(nb)
{
repeat{
cnt <- cnt+1
# Permutations des numéros de colonnes
permusam1 <- sample(c(1:5), sample(1:4))
permusam2 <- sample(c(6:10), sample(1:4))
a <- setdiff(1:5,permusam1)
aa <- sample(c(a,permusam2))
b <- setdiff(6:10,permusam2)
bb <- sample(c(b,permusam1))
# le vecteur c(aa,bb) représente l'ordre des indices de colonnes une fois permutée
DP <- matrix(c(D[,aa], D[,bb]), nrow = 10, ncol=10)
DPdiff <- abs(rowMeans(DP[,1:5]) - rowMeans(DP[,6:10]))
DPmoy <- cbind(DP, DPdiff)
# Mettre en ordre décroissant
DPdec <- DPmoy[order(DPmoy[,11], decreasing= TRUE),]
y <- marche(DPdec, DPmoy)
Ytot <- rbind(Ytot,y)
if(cnt == nb) {
break
}
}
return(Ytot)
}
result <- permutation(1000)
result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/nperm
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/1000
signi
## Devoir 1 - Question 2
## Étape 0. Indiquer l'espace de travail et charger les données dans la matrice D
##
setwd("~/Desktop/R_mydirectory/devoir1")
D <- matrix(scan("Q2_donnees.dat"),10,10,byrow=TRUE)
D
## Étape 1. Ordonner les gènes en décroissant de différentiel d’expression
# Calculer la différence des moyennes pour chaque gène, dans chaque groupe
Ddiff <- abs(rowMeans(D[,1:5]) - rowMeans(D[,6:10]))
Dmoy <- cbind(D, Ddiff)
# Mettre en ordre décroissant
Ddec <- Dmoy[order(Dmoy[,11], decreasing= TRUE),]
## Étape 2. Marche (somme cumulative) avec le sous-groupe étudié: G1, G3, G6
# Définitions de paramètres n (nombre de données) et g (nombre de données dans le sous-ensemble)
n <- 10
g <- 3
# Valeur d'un pas positif
pp <- sqrt((n-g)/g)
pp
# Valeur d'un pas négatif
pn <- -sqrt(g/(n-g))
pn
# Fonction "marche" avec les pas calculés et les données initiales (non-permutées)
marche<-function(donnees1, donnees2)
{
x <- vector(mode="numeric", length = 11)
x
for(i in 2:length(x)){
if(all(donnees1[i-1,] == donnees2[1,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[3,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[6,])){
x[i] <- x[i-1]+pp
} else {
x[i] <- x[i-1]+pn
}
}
return(x)
}
x<-marche(Ddec, Dmoy)
# Représentation graphique de la marche et du supremum
sup <- max(x)
plot(x, ylim =c(-3,3), type="b", col=ifelse(x==sup, "darkseagreen", "darkseagreen4"),
pch=ifelse(x==sup, 18, 1), cex=ifelse(x==sup, 1.5, 1))
## Étape 3: Permuter les groupes de données 10 fois
## et appliquer la fonction "marche" à chaque permutation
cnt <- 0
Ytot <- matrix(0, nrow=0, ncol=11)
permutation <- function(nb)
{
repeat{
cnt <- cnt+1
# Permutations des numéros de colonnes
permusam1 <- sample(c(1:5), sample(1:4))
permusam2 <- sample(c(6:10), sample(1:4))
a <- setdiff(1:5,permusam1)
aa <- sample(c(a,permusam2))
b <- setdiff(6:10,permusam2)
bb <- sample(c(b,permusam1))
# le vecteur c(aa,bb) représente l'ordre des indices de colonnes une fois permutée
DP <- matrix(c(D[,aa], D[,bb]), nrow = 10, ncol=10)
DPdiff <- abs(rowMeans(DP[,1:5]) - rowMeans(DP[,6:10]))
DPmoy <- cbind(DP, DPdiff)
# Mettre en ordre décroissant
DPdec <- DPmoy[order(DPmoy[,11], decreasing= TRUE),]
y <- marche(DPdec, DPmoy)
Ytot <- rbind(Ytot,y)
if(cnt == nb) {
break
}
}
return(Ytot)
}
result <- permutation(500)
result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/500
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
## Devoir 1 - Question 2
## Étape 0. Indiquer l'espace de travail et charger les données dans la matrice D
##
setwd("~/Desktop/R_mydirectory/devoir1")
D <- matrix(scan("Q2_donnees.dat"),10,10,byrow=TRUE)
D
## Étape 1. Ordonner les gènes en décroissant de différentiel d’expression
# Calculer la différence des moyennes pour chaque gène, dans chaque groupe
Ddiff <- abs(rowMeans(D[,1:5]) - rowMeans(D[,6:10]))
Dmoy <- cbind(D, Ddiff)
# Mettre en ordre décroissant
Ddec <- Dmoy[order(Dmoy[,11], decreasing= TRUE),]
## Étape 2. Marche (somme cumulative) avec le sous-groupe étudié: G1, G3, G6
# Définitions de paramètres n (nombre de données) et g (nombre de données dans le sous-ensemble)
n <- 10
g <- 3
# Valeur d'un pas positif
pp <- sqrt((n-g)/g)
pp
# Valeur d'un pas négatif
pn <- -sqrt(g/(n-g))
pn
# Fonction "marche" avec les pas calculés et les données initiales (non-permutées)
marche<-function(donnees1, donnees2)
{
x <- vector(mode="numeric", length = 11)
x
for(i in 2:length(x)){
if(all(donnees1[i-1,] == donnees2[1,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[3,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[6,])){
x[i] <- x[i-1]+pp
} else {
x[i] <- x[i-1]+pn
}
}
return(x)
}
x<-marche(Ddec, Dmoy)
# Représentation graphique de la marche et du supremum
sup <- max(x)
plot(x, ylim =c(-3,3), type="b", col=ifelse(x==sup, "darkseagreen", "darkseagreen4"),
pch=ifelse(x==sup, 18, 1), cex=ifelse(x==sup, 1.5, 1))
## Étape 3: Permuter les groupes de données 10 fois
## et appliquer la fonction "marche" à chaque permutation
cnt <- 0
Ytot <- matrix(0, nrow=0, ncol=11)
permutation <- function(nb)
{
repeat{
cnt <- cnt+1
# Permutations des numéros de colonnes
permusam1 <- sample(c(1:5), sample(1:4))
permusam2 <- sample(c(6:10), sample(1:4))
a <- setdiff(1:5,permusam1)
aa <- sample(c(a,permusam2))
b <- setdiff(6:10,permusam2)
bb <- sample(c(b,permusam1))
# le vecteur c(aa,bb) représente l'ordre des indices de colonnes une fois permutée
DP <- matrix(c(D[,aa], D[,bb]), nrow = 10, ncol=10)
DPdiff <- abs(rowMeans(DP[,1:5]) - rowMeans(DP[,6:10]))
DPmoy <- cbind(DP, DPdiff)
# Mettre en ordre décroissant
DPdec <- DPmoy[order(DPmoy[,11], decreasing= TRUE),]
y <- marche(DPdec, DPmoy)
Ytot <- rbind(Ytot,y)
if(cnt == nb) {
break
}
}
return(Ytot)
}
result <- permutation(2000)
result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/2000
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
## Devoir 1 - Question 2
## Étape 0. Indiquer l'espace de travail et charger les données dans la matrice D
##
setwd("~/Desktop/R_mydirectory/devoir1")
D <- matrix(scan("Q2_donnees.dat"),10,10,byrow=TRUE)
D
## Étape 1. Ordonner les gènes en décroissant de différentiel d’expression
# Calculer la différence des moyennes pour chaque gène, dans chaque groupe
Ddiff <- abs(rowMeans(D[,1:5]) - rowMeans(D[,6:10]))
Dmoy <- cbind(D, Ddiff)
# Mettre en ordre décroissant
Ddec <- Dmoy[order(Dmoy[,11], decreasing= TRUE),]
## Étape 2. Marche (somme cumulative) avec le sous-groupe étudié: G1, G3, G6
# Définitions de paramètres n (nombre de données) et g (nombre de données dans le sous-ensemble)
n <- 10
g <- 3
# Valeur d'un pas positif
pp <- sqrt((n-g)/g)
pp
# Valeur d'un pas négatif
pn <- -sqrt(g/(n-g))
pn
# Fonction "marche" avec les pas calculés et les données initiales (non-permutées)
marche<-function(donnees1, donnees2)
{
x <- vector(mode="numeric", length = 11)
x
for(i in 2:length(x)){
if(all(donnees1[i-1,] == donnees2[1,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[3,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[6,])){
x[i] <- x[i-1]+pp
} else {
x[i] <- x[i-1]+pn
}
}
return(x)
}
x<-marche(Ddec, Dmoy)
# Représentation graphique de la marche et du supremum
sup <- max(x)
plot(x, ylim =c(-3,3), type="b", col=ifelse(x==sup, "darkseagreen", "darkseagreen4"),
pch=ifelse(x==sup, 18, 1), cex=ifelse(x==sup, 1.5, 1))
## Étape 3: Permuter les groupes de données 10 fois
## et appliquer la fonction "marche" à chaque permutation
cnt <- 0
Ytot <- matrix(0, nrow=0, ncol=11)
permutation <- function(nb)
{
repeat{
cnt <- cnt+1
# Permutations des numéros de colonnes
permusam1 <- sample(c(1:5), sample(1:4))
permusam2 <- sample(c(6:10), sample(1:4))
a <- setdiff(1:5,permusam1)
aa <- sample(c(a,permusam2))
b <- setdiff(6:10,permusam2)
bb <- sample(c(b,permusam1))
# le vecteur c(aa,bb) représente l'ordre des indices de colonnes une fois permutée
DP <- matrix(c(D[,aa], D[,bb]), nrow = 10, ncol=10)
DPdiff <- abs(rowMeans(DP[,1:5]) - rowMeans(DP[,6:10]))
DPmoy <- cbind(DP, DPdiff)
# Mettre en ordre décroissant
DPdec <- DPmoy[order(DPmoy[,11], decreasing= TRUE),]
y <- marche(DPdec, DPmoy)
Ytot <- rbind(Ytot,y)
if(cnt == nb) {
break
}
}
return(Ytot)
}
result <- permutation(2000)
result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/2000
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
## Devoir 1 - Question 2
## Étape 0. Indiquer l'espace de travail et charger les données dans la matrice D
##
setwd("~/Desktop/R_mydirectory/devoir1")
D <- matrix(scan("Q2_donnees.dat"),10,10,byrow=TRUE)
D
## Étape 1. Ordonner les gènes en décroissant de différentiel d’expression
# Calculer la différence des moyennes pour chaque gène, dans chaque groupe
Ddiff <- abs(rowMeans(D[,1:5]) - rowMeans(D[,6:10]))
Dmoy <- cbind(D, Ddiff)
# Mettre en ordre décroissant
Ddec <- Dmoy[order(Dmoy[,11], decreasing= TRUE),]
## Étape 2. Marche (somme cumulative) avec le sous-groupe étudié: G1, G3, G6
# Définitions de paramètres n (nombre de données) et g (nombre de données dans le sous-ensemble)
n <- 10
g <- 3
# Valeur d'un pas positif
pp <- sqrt((n-g)/g)
pp
# Valeur d'un pas négatif
pn <- -sqrt(g/(n-g))
pn
# Fonction "marche" avec les pas calculés et les données initiales (non-permutées)
marche<-function(donnees1, donnees2)
{
x <- vector(mode="numeric", length = 11)
x
for(i in 2:length(x)){
if(all(donnees1[i-1,] == donnees2[1,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[3,])){
x[i] <- x[i-1]+pp
} else if(all(donnees1[i-1,] == donnees2[6,])){
x[i] <- x[i-1]+pp
} else {
x[i] <- x[i-1]+pn
}
}
return(x)
}
x<-marche(Ddec, Dmoy)
# Représentation graphique de la marche et du supremum
sup <- max(x)
plot(x, ylim =c(-3,3), type="b", col=ifelse(x==sup, "darkseagreen", "darkseagreen4"),
pch=ifelse(x==sup, 18, 1), cex=ifelse(x==sup, 1.5, 1))
## Étape 3: Permuter les groupes de données 10 fois
## et appliquer la fonction "marche" à chaque permutation
cnt <- 0
Ytot <- matrix(0, nrow=0, ncol=11)
permutation <- function(nb)
{
repeat{
cnt <- cnt+1
# Permutations des numéros de colonnes
permusam1 <- sample(c(1:5), sample(1:4))
permusam2 <- sample(c(6:10), sample(1:4))
a <- setdiff(1:5,permusam1)
aa <- sample(c(a,permusam2))
b <- setdiff(6:10,permusam2)
bb <- sample(c(b,permusam1))
# le vecteur c(aa,bb) représente l'ordre des indices de colonnes une fois permutée
DP <- matrix(c(D[,aa], D[,bb]), nrow = 10, ncol=10)
DPdiff <- abs(rowMeans(DP[,1:5]) - rowMeans(DP[,6:10]))
DPmoy <- cbind(DP, DPdiff)
# Mettre en ordre décroissant
DPdec <- DPmoy[order(DPmoy[,11], decreasing= TRUE),]
y <- marche(DPdec, DPmoy)
Ytot <- rbind(Ytot,y)
if(cnt == nb) {
break
}
}
return(Ytot)
}
result <- permutation(2000)
result
# taux de permutations dont le supremum est supérieur à celui des données initiales (à titre indicatif)
sup2 <- apply(abs(result), 1, max)
suptrue <- ifelse(sup<sup2, TRUE, FALSE)
signi <- (sum(suptrue == TRUE))/2000
signi
# représentation graphique des marches pour les données permutées (à titre indicatif)
matplot(t(result), type="l")
View(result)
View(result)
